# redis 持久化

## RDB 持久化
Redis 使用操作系统的多进程写时复制(Copy On Write) 机制来实现快照持久化。

伪代码描述
```bash
pid = os.fork()
if pid > 0:
    handle_client_requests() # 父进程继续处理客户端请求
if pid == 0:
    handle_snapshot_write() # 子进程处理快照写磁盘
if pid < 0:
    # fork error
```

父进程对其中一个页面的数据进行修改时，会将被共享的页面复制一份分离出来，然后对这个复制的页面进行修改。
这时子进程相应的页面没有变化，还是进程产生时那一瞬间的数据。

### BGSAVE
```
save 900 1
save 300 10
save 60 10000
```
只要满足三个条件之一，BGSAVE就会执行
- 900s 内，执行至少1次修改
- 300s 内，执行至少10次修改
- 60s 内，执行至少10000次修改

### od 命令
od 命令可以查看rdb文件内容
```
od -c dump.rdb
```

### 小结
- RDB文件是快照，是二进制文件。
- SAVE是服务器进程执行，阻塞式。BGSAVE是子进程执行，不会阻塞。
- 不同类型的KV，RDB采用不同的方式保存。

## AOF持久化
AOF 日志只记录对内存进行修改的指令记录。分为：命令追加、文件写入、文件同步。

### AOF重写
bgrewriteaof 指令用于对AOF 日志进行瘦身。
- 开辟一个子进程对内存进行遍历转换成一系列Redis 的操作指令，序列化到一个新的AOF 日志文件中。
- 序列化完毕后再将操作期间发生的增量AOF 日志追加到这个新的AOF 日志文件，追加完毕后立即替代旧的AOF 日志文件。

### fsync
程序对AOF 日志文件进行写操作时，实际是将内容写到了内核为文件描述符分配的一个内存缓存中，然后内核会异步将脏数据刷回磁盘。

Linux 的glibc提供了fsync(int fd)函数可以将指定文件的内容强制从内核缓存刷到磁盘。生产环境的服务器中，Redis 通常是每隔1s 左右执行一次fsync 操作。

## Redis 4.0 混合持久化
- 重启 Redis 时，很少使用rdb 来恢复内存状态，因为会丢失大量数据。
- 通常使用AOF 日志重放，但重放AOF 日志相对rdb 要慢很多，启动需要花费很长的时间。

Redis 4.0 带来了一个新的持久化选项——混合持久化。将rdb 文件的内容和增量的AOF 日志文件存在一起。
AOF 日志不再是全量的日志，而是自持久化开始到持久化结束的这段时间发生的增量AOF 日志，通常这部分AOF 日志很小。

Redis 重启的时候
- 先加载rdb 的内容。
- 然后重放增量AOF 日志，就可以完全替代之前的AOF 全量文件重放。
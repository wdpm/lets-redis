# redis 漏斗限流
## 灵感来源
漏洞的容量是有限的，如果将漏嘴堵住，然后一直往里面灌水，它就会变满，直至再也装不进去。
如果将漏嘴放开，水就会往下流，流走一部分之后，就又可以继续往里面灌。

- 漏斗的剩余空间代表着当前行为可以持续进行的数量。
- 漏嘴的流水速率代表着系统允许该行为的最大频率。

## 单机版漏斗算法
[FunnelRateLimiter](..\src\main\java\io\github\wdpm\redis\limit\FunnelRateLimiter.java)

腾出空间取决于过去多久以及流水的速率。Funnel 对象占据的空间大小不再和行为的频率成正比，它的空间占用是一个常量。

## 分布式漏斗算法
观察 Funnel 对象的几个字段，可以将 Funnel 对象的内容按字段存储到一个 hash 结构中，
灌水的时候将 hash 结构的字段取出来进行逻辑运算后，再将新值回填到 hash 结构中就完成了一次行为频度的检测。

但是我们无法保证整个过程的原子性。从 hash 结构中取值，然后在内存里运算，再回填到 hash 结构，这三个过程无法原子化，意味着需要进行适当的加锁控制。

## redis-cell
Redis 4.0 提供了一个限流 Redis 模块，redis-cell。该模块也使用了漏斗算法，并提供了原子的限流指令。
```bash
cl.throttle alice:reply 15 30 60 1
```

漏斗的初始容量为 15，允许「用户alice回复行为」的频率为最多 30 次/每 60s。
- 一开始可以连续回复 15 个帖子，然后开始受漏水速率的影响。
- 这个指令中漏水速率变成了 2 个参数，替代了之前的单个浮点数。用两个参数相除的结果来表达漏水速率相对单个浮点数要更加直观一些。

```bash
> cl.throttle alice:reply 15 30 60
1) (integer) 0 # 0 表示允许，1表示拒绝
2) (integer) 15 # 漏斗容量capacity
3) (integer) 14 # 漏斗剩余空间left_quota
4) (integer) -1 # 如果拒绝了，需要多长时间后再试(漏斗有空间了，单位秒) => 划重点：重试时间
5) (integer) 2 # 多长时间后，漏斗完全空出来(left_quota==capacity，单位秒)
```

在执行限流指令时，如果被拒绝了，就需要丢弃或重试。
cl.throttle 指令直接取返回结果数组的第四个值进行 sleep 即可，如果不想阻塞线程，可以异步定时任务来重试。